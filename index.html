<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>é€²éšæ–‡ä»¶æ¯”å°å·¥å…·</title>
<link rel="stylesheet" href="style.css">
<style>
  
</style>
</head>
<body>
<div class="container">
  <h2>ğŸ“ é€²éšæ–‡ä»¶æ¯”å°å·¥å…·</h2>
  
  <div class="input-section">
    <div class="input-group">
      <label for="refText">ğŸ¯ æ¨™æº–æ–‡ä»¶ï¼ˆæ­£ç¢ºç¨¿ï¼‰</label>
      <textarea id="refText" rows="10" placeholder="è«‹è¼¸å…¥æ¨™æº–ç‰ˆæœ¬çš„æ–‡ä»¶å…§å®¹..."></textarea>
    </div>
    <div class="input-group">
      <label for="userText">âœï¸ æ¯”å°æ–‡ä»¶ï¼ˆå¾…æª¢æŸ¥ç¨¿ï¼‰</label>
      <textarea id="userText" rows="10" placeholder="è«‹è¼¸å…¥éœ€è¦æ¯”å°çš„æ–‡ä»¶å…§å®¹..."></textarea>
    </div>
  </div>
  
  <div class="button-group">
    <button onclick="compareTexts()">ğŸ” é–‹å§‹æ¯”å°</button>
    <button onclick="clearAll()" style="background: #95a5a6; margin-left: 10px;">ğŸ—‘ï¸ æ¸…ç©ºå…§å®¹</button>
  </div>
  
  <div class="legend">
    <div class="legend-item">
      <span class="correct">æ­£ç¢º</span> - å®Œå…¨æ­£ç¢ºçš„å…§å®¹
    </div>
    <div class="legend-item">
      <span class="almost">è¿‘ä¼¼</span> - æ‹¼å¯«æ¥è¿‘ä½†ä¸å®Œå…¨æ­£ç¢º
    </div>
    <div class="legend-item">
      <span class="wrong">éŒ¯èª¤</span> - éŒ¯èª¤çš„å…§å®¹
    </div>
    <div class="legend-item">
      <span class="missing">[éºæ¼]</span> - éºæ¼çš„å…§å®¹
    </div>
    <div class="legend-item">
      <span class="replacement">â†’å»ºè­°</span> - ä¿®æ­£å»ºè­°
    </div>
  </div>

  <div class="result" id="output"></div>
  <div class="stats" id="statistics"></div>
</div>

<script>
// --- å·¥å…·å‡½æ•¸ ---
function tokenize(text) {
  return text
    .replace(/[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼š]/g, ' ')  // è™•ç†ä¸­æ–‡æ¨™é»
    .replace(/([A-Z])\.([A-Z])/g, '$1$2')  // è™•ç†åƒ U.S. é€™æ¨£çš„ç¸®å¯«ï¼Œè®Šæˆ US
    .replace(/[^\w\s\u4e00-\u9fff]/g, ' ')  // ä¿ç•™ä¸­è‹±æ–‡å’Œæ•¸å­—
    .split(/\s+/)
    .filter(word => word.length > 0);
}

// --- æ”¹é€²çš„è©å½¢é‚„åŸ ---
function lemmatize(word) {
  const lower = word.toLowerCase();
  
  // è‹±æ–‡è©å½¢é‚„åŸ
  const irregularVerbs = {
    'went': 'go', 'did': 'do', 'was': 'be', 'were': 'be',
    'had': 'have', 'said': 'say', 'got': 'get'
  };
  
  if (irregularVerbs[lower]) return irregularVerbs[lower];
  
  // è¦å‰‡è®ŠåŒ–
  if (lower.endsWith('ies') && lower.length > 4) return lower.slice(0, -3) + 'y';
  if (lower.endsWith('ied') && lower.length > 4) return lower.slice(0, -3) + 'y';
  if (lower.endsWith('ing') && lower.length > 4) return lower.slice(0, -3);
  if (lower.endsWith('ed') && lower.length > 3) return lower.slice(0, -2);
  if (lower.endsWith('s') && lower.length > 2 && !lower.endsWith('ss')) return lower.slice(0, -1);
  
  return lower;
}

// --- è¨ˆç®— Levenshtein è·é›¢ ---
function levenshtein(a, b) {
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  
  const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
  
  for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
  for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
  
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      const indicator = a[i-1] === b[j-1] ? 0 : 1;
      matrix[j][i] = Math.min(
        matrix[j][i-1] + 1,     // deletion
        matrix[j-1][i] + 1,     // insertion
        matrix[j-1][i-1] + indicator // substitution
      );
    }
  }
  
  return matrix[b.length][a.length];
}

// --- åˆ¤æ–·ç›¸ä¼¼åº¦ ---
function getSimilarity(word1, word2) {
  const dist = levenshtein(word1, word2);
  const maxLen = Math.max(word1.length, word2.length);
  return (maxLen - dist) / maxLen;
}

// --- æ”¹é€²çš„æ¯”å°ç®—æ³•ä½¿ç”¨å‹•æ…‹è¦åŠƒ ---
function advancedCompare(refWords, userWords) {
  const n = refWords.length;
  const m = userWords.length;
  
  // å»ºç«‹DPè¡¨æ ¼ï¼šdp[i][j]è¡¨ç¤ºrefWords[0..i-1]å’ŒuserWords[0..j-1]çš„æœ€å„ªæ¯”å°æˆæœ¬
  const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));
  const trace = Array(n + 1).fill(null).map(() => Array(m + 1).fill(null));
  
  // åˆå§‹åŒ–ï¼šè™•ç†å…¨éƒ¨åˆªé™¤æˆ–æ’å…¥çš„æƒ…æ³
  for (let i = 0; i <= n; i++) {
    dp[i][0] = i;
    if (i > 0) trace[i][0] = 'delete';
  }
  for (let j = 0; j <= m; j++) {
    dp[0][j] = j;
    if (j > 0) trace[0][j] = 'insert';
  }
  
  // å¡«å……DPè¡¨æ ¼
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      const refWord = refWords[i - 1];
      const userWord = userWords[j - 1];
      const refLemma = lemmatize(refWord);
      const userLemma = lemmatize(userWord);
      
      // è¨ˆç®—å„ç¨®æ“ä½œçš„æˆæœ¬
      let matchCost;
      if (refLemma === userLemma) {
        matchCost = dp[i-1][j-1]; // å®Œç¾åŒ¹é…ï¼Œç„¡æˆæœ¬
      } else {
        const similarity = getSimilarity(refWord, userWord);
        if (similarity > 0.7) {
          matchCost = dp[i-1][j-1] + 0.5; // ç›¸ä¼¼åŒ¹é…ï¼Œå°æˆæœ¬
        } else {
          matchCost = dp[i-1][j-1] + 2; // æ›¿æ›ï¼Œé«˜æˆæœ¬
        }
      }
      
      const deleteCost = dp[i-1][j] + 1; // åˆªé™¤ï¼ˆåŸç¨¿ä¸­æœ‰ï¼Œç”¨æˆ¶ç¨¿ä¸­æ²’æœ‰ï¼‰
      const insertCost = dp[i][j-1] + 1; // æ’å…¥ï¼ˆç”¨æˆ¶ç¨¿ä¸­æœ‰ï¼ŒåŸç¨¿ä¸­æ²’æœ‰ï¼‰
      
      // é¸æ“‡æœ€å°æˆæœ¬çš„æ“ä½œ
      if (matchCost <= deleteCost && matchCost <= insertCost) {
        dp[i][j] = matchCost;
        trace[i][j] = 'match';
      } else if (deleteCost <= insertCost) {
        dp[i][j] = deleteCost;
        trace[i][j] = 'delete';
      } else {
        dp[i][j] = insertCost;
        trace[i][j] = 'insert';
      }
    }
  }
  
  // å›æº¯æ§‹å»ºçµæœ
  const result = [];
  let i = n, j = m;
  
  while (i > 0 || j > 0) {
    const operation = trace[i][j];
    
    if (operation === 'match') {
      const refWord = refWords[i - 1];
      const userWord = userWords[j - 1];
      const refLemma = lemmatize(refWord);
      const userLemma = lemmatize(userWord);
      
      if (refLemma === userLemma) {
        result.unshift({
          type: 'correct',
          word: userWord,
          position: j - 1
        });
      } else {
        const similarity = getSimilarity(refWord, userWord);
        if (similarity > 0.7) {
          result.unshift({
            type: 'almost',
            word: userWord,
            expected: refWord,
            position: j - 1
          });
        } else {
          result.unshift({
            type: 'wrong',
            word: userWord,
            expected: refWord,
            position: j - 1
          });
        }
      }
      i--; j--;
    } else if (operation === 'delete') {
      // åŸç¨¿ä¸­æœ‰ï¼Œç”¨æˆ¶ç¨¿ä¸­æ²’æœ‰ï¼ˆéºæ¼ï¼‰
      result.unshift({
        type: 'missing',
        word: refWords[i - 1],
        position: i - 1
      });
      i--;
    } else if (operation === 'insert') {
      // ç”¨æˆ¶ç¨¿ä¸­æœ‰ï¼ŒåŸç¨¿ä¸­æ²’æœ‰ï¼ˆå¤šé¤˜ï¼‰
      result.unshift({
        type: 'extra',
        word: userWords[j - 1],
        position: j - 1
      });
      j--;
    }
  }
  
  return { result };
}

// --- çµ±è¨ˆåˆ†æ ---
function computeStats(result) {
  console.log('computeStats æ¥æ”¶åˆ°çš„çµæœ:', result);
  
  if (!result || !Array.isArray(result)) {
    console.log('result ä¸æ˜¯é™£åˆ—ï¼Œè¿”å›é»˜èªå€¼');
    return {
      accuracy: 0
    };
  }
  
  const total = result.length;
  let correct = 0;
  let almost = 0;
  
  result.forEach(item => {
    if (item && item.type === 'correct') {
      correct++;
    } else if (item && item.type === 'almost') {
      almost++;
    }
  });
  
  const accuracy = total > 0 ? ((correct + almost * 0.5) / total * 100).toFixed(1) : 0;
  
  return {
    accuracy
  };
}

// --- ä¸»æ¯”å°å‡½æ•¸ ---
function compareTexts() {
  try {
    const refText = document.getElementById("refText").value.trim();
    const userText = document.getElementById("userText").value.trim();
    
    if (!refText || !userText) {
      document.getElementById("output").innerHTML = "<span style='color: red;'>âš ï¸ è«‹è¼¸å…¥å…©å€‹æ–‡ä»¶çš„å…§å®¹</span>";
      return;
    }
    
    const refWords = tokenize(refText);
    const userWords = tokenize(userText);
    const { result } = advancedCompare(refWords, userWords);

    // ç”Ÿæˆæ¯”å°çµæœ
    let resultHTML = "";
    result.forEach(item => {
      switch(item.type) {
        case 'correct':
          resultHTML += `<span class="correct">${item.word}</span> `;
          break;
        case 'almost':
          resultHTML += `<span class="almost" title="å»ºè­°æ”¹ç‚º: ${item.expected}">${item.word}</span> `;
          resultHTML += `<span class="replacement">â†’${item.expected}</span> `;
          break;
        case 'wrong':
          resultHTML += `<span class="wrong" title="éŒ¯èª¤: ${item.word}">${item.word}</span> `;
          if (item.expected) {
            resultHTML += `<span class="replacement">â†’${item.expected}</span> `;
          }
          break;
        case 'missing':
          resultHTML += `<span class="missing">[éºæ¼: ${item.word}]</span> `;
          break;
        case 'extra':
          resultHTML += `<span class="wrong" title="å¤šé¤˜å…§å®¹">${item.word}</span> `;
          break;
      }
    });
    
    document.getElementById("output").innerHTML = resultHTML || "æ²’æœ‰æ‰¾åˆ°ä»»ä½•å…§å®¹";

    // çµ±è¨ˆåˆ†æ - åªé¡¯ç¤ºæ­£ç¢ºç‡
    const stats = computeStats(result);
    let statsHTML = `
      <h3>ğŸ“Š æ¯”å°çµ±è¨ˆ</h3>
      <div class="progress-bar">
        <div class="progress-fill" style="width: ${stats.accuracy}%">${stats.accuracy}%</div>
      </div>
      <p><strong>æ•´é«”æ­£ç¢ºç‡:</strong> <span style="font-size: 1.2em; color: ${stats.accuracy > 80 ? '#27ae60' : stats.accuracy > 60 ? '#f39c12' : '#e74c3c'};">${stats.accuracy}%</span></p>
    `;
    
    document.getElementById("statistics").innerHTML = statsHTML;

  } catch(e) {
    document.getElementById("output").innerHTML = "<span style='color: red;'>âŒ ç¨‹å¼åŸ·è¡ŒéŒ¯èª¤ï¼Œè«‹æª¢æŸ¥è¼¸å…¥å…§å®¹</span>";
    console.error('æ¯”å°éŒ¯èª¤:', e);
  }
}

// --- æ¸…ç©ºå‡½æ•¸ ---
function clearAll() {
  document.getElementById("refText").value = "";
  document.getElementById("userText").value = "";
  document.getElementById("output").innerHTML = "";
  document.getElementById("statistics").innerHTML = "";
}

// --- é é¢è¼‰å…¥å®Œæˆå¾Œçš„è™•ç† ---
document.addEventListener('DOMContentLoaded', function() {
  // ç¤ºä¾‹æ–‡æœ¬
  const exampleRef = "äººå·¥æ™ºæ…§æŠ€è¡“åœ¨ç¾ä»£ç¤¾æœƒä¸­æ‰®æ¼”è‘—è¶Šä¾†è¶Šé‡è¦çš„è§’è‰²ï¼Œå¾é†«ç™‚è¨ºæ–·åˆ°è‡ªå‹•é§•é§›æ±½è»Šéƒ½æœ‰å»£æ³›æ‡‰ç”¨ã€‚";
  const exampleUser = "äººå·¥æ™ºèƒ½æŠ€è¡“åœ¨ç¾ä»£ç¤¾æœƒä¸­æ‰®æ¼”è‘—è¶Šä¾†è¶Šé‡è¦çš„è§’è‰²ï¼Œå¾é†«ç™‚çæ–·åˆ°è‡ªå‹•é§•é§›æ±½è»Šéƒ½æœ‰å»£æ³›æ‡‰ç”¨ã€‚";
  
  // å¯ä»¥é¸æ“‡æ˜¯å¦è¼‰å…¥ç¤ºä¾‹
  // document.getElementById("refText").value = exampleRef;
  // document.getElementById("userText").value = exampleUser;
});
</script>

</body>
</html>
