<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>進階文件比對工具</title>
<link rel="stylesheet" href="style.css">
<style>
  
</style>
</head>
<body>
<div class="container">
  <h2>📝 進階文件比對工具</h2>
  
  <div class="input-section">
    <div class="input-group">
      <label for="refText">🎯 標準文件（正確稿）</label>
      <textarea id="refText" rows="10" placeholder="請輸入標準版本的文件內容..."></textarea>
    </div>
    <div class="input-group">
      <label for="userText">✏️ 比對文件（待檢查稿）</label>
      <textarea id="userText" rows="10" placeholder="請輸入需要比對的文件內容..."></textarea>
    </div>
  </div>
  
  <div class="button-group">
    <button onclick="compareTexts()">🔍 開始比對</button>
    <button onclick="clearAll()" style="background: #95a5a6; margin-left: 10px;">🗑️ 清空內容</button>
  </div>
  
  <div class="legend">
    <div class="legend-item">
      <span class="correct">正確</span> - 完全正確的內容
    </div>
    <div class="legend-item">
      <span class="almost">近似</span> - 拼寫接近但不完全正確
    </div>
    <div class="legend-item">
      <span class="wrong">錯誤</span> - 錯誤的內容
    </div>
    <div class="legend-item">
      <span class="missing">[遺漏]</span> - 遺漏的內容
    </div>
    <div class="legend-item">
      <span class="replacement">→建議</span> - 修正建議
    </div>
  </div>

  <div class="result" id="output"></div>
  <div class="stats" id="statistics"></div>
</div>

<script>
// --- 工具函數 ---
function tokenize(text) {
  return text
    .replace(/[，。！？；：]/g, ' ')  // 處理中文標點
    .replace(/([A-Z])\.([A-Z])/g, '$1$2')  // 處理像 U.S. 這樣的縮寫，變成 US
    .replace(/[^\w\s\u4e00-\u9fff]/g, ' ')  // 保留中英文和數字
    .split(/\s+/)
    .filter(word => word.length > 0);
}

// --- 改進的詞形還原 ---
function lemmatize(word) {
  const lower = word.toLowerCase();
  
  // 英文詞形還原
  const irregularVerbs = {
    'went': 'go', 'did': 'do', 'was': 'be', 'were': 'be',
    'had': 'have', 'said': 'say', 'got': 'get'
  };
  
  if (irregularVerbs[lower]) return irregularVerbs[lower];
  
  // 規則變化
  if (lower.endsWith('ies') && lower.length > 4) return lower.slice(0, -3) + 'y';
  if (lower.endsWith('ied') && lower.length > 4) return lower.slice(0, -3) + 'y';
  if (lower.endsWith('ing') && lower.length > 4) return lower.slice(0, -3);
  if (lower.endsWith('ed') && lower.length > 3) return lower.slice(0, -2);
  if (lower.endsWith('s') && lower.length > 2 && !lower.endsWith('ss')) return lower.slice(0, -1);
  
  return lower;
}

// --- 計算 Levenshtein 距離 ---
function levenshtein(a, b) {
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  
  const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
  
  for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
  for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
  
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      const indicator = a[i-1] === b[j-1] ? 0 : 1;
      matrix[j][i] = Math.min(
        matrix[j][i-1] + 1,     // deletion
        matrix[j-1][i] + 1,     // insertion
        matrix[j-1][i-1] + indicator // substitution
      );
    }
  }
  
  return matrix[b.length][a.length];
}

// --- 判斷相似度 ---
function getSimilarity(word1, word2) {
  const dist = levenshtein(word1, word2);
  const maxLen = Math.max(word1.length, word2.length);
  return (maxLen - dist) / maxLen;
}

// --- 改進的比對算法使用動態規劃 ---
function advancedCompare(refWords, userWords) {
  const n = refWords.length;
  const m = userWords.length;
  
  // 建立DP表格：dp[i][j]表示refWords[0..i-1]和userWords[0..j-1]的最優比對成本
  const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));
  const trace = Array(n + 1).fill(null).map(() => Array(m + 1).fill(null));
  
  // 初始化：處理全部刪除或插入的情況
  for (let i = 0; i <= n; i++) {
    dp[i][0] = i;
    if (i > 0) trace[i][0] = 'delete';
  }
  for (let j = 0; j <= m; j++) {
    dp[0][j] = j;
    if (j > 0) trace[0][j] = 'insert';
  }
  
  // 填充DP表格
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      const refWord = refWords[i - 1];
      const userWord = userWords[j - 1];
      const refLemma = lemmatize(refWord);
      const userLemma = lemmatize(userWord);
      
      // 計算各種操作的成本
      let matchCost;
      if (refLemma === userLemma) {
        matchCost = dp[i-1][j-1]; // 完美匹配，無成本
      } else {
        const similarity = getSimilarity(refWord, userWord);
        if (similarity > 0.7) {
          matchCost = dp[i-1][j-1] + 0.5; // 相似匹配，小成本
        } else {
          matchCost = dp[i-1][j-1] + 2; // 替換，高成本
        }
      }
      
      const deleteCost = dp[i-1][j] + 1; // 刪除（原稿中有，用戶稿中沒有）
      const insertCost = dp[i][j-1] + 1; // 插入（用戶稿中有，原稿中沒有）
      
      // 選擇最小成本的操作
      if (matchCost <= deleteCost && matchCost <= insertCost) {
        dp[i][j] = matchCost;
        trace[i][j] = 'match';
      } else if (deleteCost <= insertCost) {
        dp[i][j] = deleteCost;
        trace[i][j] = 'delete';
      } else {
        dp[i][j] = insertCost;
        trace[i][j] = 'insert';
      }
    }
  }
  
  // 回溯構建結果
  const result = [];
  let i = n, j = m;
  
  while (i > 0 || j > 0) {
    const operation = trace[i][j];
    
    if (operation === 'match') {
      const refWord = refWords[i - 1];
      const userWord = userWords[j - 1];
      const refLemma = lemmatize(refWord);
      const userLemma = lemmatize(userWord);
      
      if (refLemma === userLemma) {
        result.unshift({
          type: 'correct',
          word: userWord,
          position: j - 1
        });
      } else {
        const similarity = getSimilarity(refWord, userWord);
        if (similarity > 0.7) {
          result.unshift({
            type: 'almost',
            word: userWord,
            expected: refWord,
            position: j - 1
          });
        } else {
          result.unshift({
            type: 'wrong',
            word: userWord,
            expected: refWord,
            position: j - 1
          });
        }
      }
      i--; j--;
    } else if (operation === 'delete') {
      // 原稿中有，用戶稿中沒有（遺漏）
      result.unshift({
        type: 'missing',
        word: refWords[i - 1],
        position: i - 1
      });
      i--;
    } else if (operation === 'insert') {
      // 用戶稿中有，原稿中沒有（多餘）
      result.unshift({
        type: 'extra',
        word: userWords[j - 1],
        position: j - 1
      });
      j--;
    }
  }
  
  return { result };
}

// --- 統計分析 ---
function computeStats(result) {
  console.log('computeStats 接收到的結果:', result);
  
  if (!result || !Array.isArray(result)) {
    console.log('result 不是陣列，返回默認值');
    return {
      accuracy: 0
    };
  }
  
  const total = result.length;
  let correct = 0;
  let almost = 0;
  
  result.forEach(item => {
    if (item && item.type === 'correct') {
      correct++;
    } else if (item && item.type === 'almost') {
      almost++;
    }
  });
  
  const accuracy = total > 0 ? ((correct + almost * 0.5) / total * 100).toFixed(1) : 0;
  
  return {
    accuracy
  };
}

// --- 主比對函數 ---
function compareTexts() {
  try {
    const refText = document.getElementById("refText").value.trim();
    const userText = document.getElementById("userText").value.trim();
    
    if (!refText || !userText) {
      document.getElementById("output").innerHTML = "<span style='color: red;'>⚠️ 請輸入兩個文件的內容</span>";
      return;
    }
    
    const refWords = tokenize(refText);
    const userWords = tokenize(userText);
    const { result } = advancedCompare(refWords, userWords);

    // 生成比對結果
    let resultHTML = "";
    result.forEach(item => {
      switch(item.type) {
        case 'correct':
          resultHTML += `<span class="correct">${item.word}</span> `;
          break;
        case 'almost':
          resultHTML += `<span class="almost" title="建議改為: ${item.expected}">${item.word}</span> `;
          resultHTML += `<span class="replacement">→${item.expected}</span> `;
          break;
        case 'wrong':
          resultHTML += `<span class="wrong" title="錯誤: ${item.word}">${item.word}</span> `;
          if (item.expected) {
            resultHTML += `<span class="replacement">→${item.expected}</span> `;
          }
          break;
        case 'missing':
          resultHTML += `<span class="missing">[遺漏: ${item.word}]</span> `;
          break;
        case 'extra':
          resultHTML += `<span class="wrong" title="多餘內容">${item.word}</span> `;
          break;
      }
    });
    
    document.getElementById("output").innerHTML = resultHTML || "沒有找到任何內容";

    // 統計分析 - 只顯示正確率
    const stats = computeStats(result);
    let statsHTML = `
      <h3>📊 比對統計</h3>
      <div class="progress-bar">
        <div class="progress-fill" style="width: ${stats.accuracy}%">${stats.accuracy}%</div>
      </div>
      <p><strong>整體正確率:</strong> <span style="font-size: 1.2em; color: ${stats.accuracy > 80 ? '#27ae60' : stats.accuracy > 60 ? '#f39c12' : '#e74c3c'};">${stats.accuracy}%</span></p>
    `;
    
    document.getElementById("statistics").innerHTML = statsHTML;

  } catch(e) {
    document.getElementById("output").innerHTML = "<span style='color: red;'>❌ 程式執行錯誤，請檢查輸入內容</span>";
    console.error('比對錯誤:', e);
  }
}

// --- 清空函數 ---
function clearAll() {
  document.getElementById("refText").value = "";
  document.getElementById("userText").value = "";
  document.getElementById("output").innerHTML = "";
  document.getElementById("statistics").innerHTML = "";
}

// --- 頁面載入完成後的處理 ---
document.addEventListener('DOMContentLoaded', function() {
  // 示例文本
  const exampleRef = "人工智慧技術在現代社會中扮演著越來越重要的角色，從醫療診斷到自動駕駛汽車都有廣泛應用。";
  const exampleUser = "人工智能技術在現代社會中扮演著越來越重要的角色，從醫療珍斷到自動駕駛汽車都有廣泛應用。";
  
  // 可以選擇是否載入示例
  // document.getElementById("refText").value = exampleRef;
  // document.getElementById("userText").value = exampleUser;
});
</script>

</body>
</html>
